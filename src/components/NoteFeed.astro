---
const rssUrl = 'https://note.com/iktahana/rss';
const maxItems = 5;

type FeedItem = {
	title: string;
	link: string;
	description: string;
	date: Date | null;
};

type FeedItemWithLabel = FeedItem & {
	dateLabel: string;
};

const decodeEntities = (value: string) =>
	value
		.replace(/&amp;/g, '&')
		.replace(/&lt;/g, '<')
		.replace(/&gt;/g, '>')
		.replace(/&quot;/g, '"')
		.replace(/&#39;/g, "'");

const cleanText = (value: string) => decodeEntities(value.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim());

const truncateText = (value: string, maxLength: number) =>
	value.length > maxLength ? `${value.slice(0, maxLength).trim()}…` : value;

const extractTag = (item: string, tag: string) => {
	const match = item.match(new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`));
	if (!match) {
		return '';
	}

	return cleanText(match[1].replace(/<!\[CDATA\[|\]\]>/g, ''));
};

const parseItems = (xml: string): FeedItem[] => {
	const items: FeedItem[] = [];
	for (const match of xml.matchAll(/<item>([\s\S]*?)<\/item>/g)) {
		const item = match[1];
		const title = extractTag(item, 'title');
		const link = extractTag(item, 'link');
		const description = extractTag(item, 'description');
		const pubDate = extractTag(item, 'pubDate');
		const date = pubDate ? new Date(pubDate) : null;

		items.push({ title, link, description, date });
	}
	return items;
};

let feedItems: FeedItem[] = [];
try {
	const response = await fetch(rssUrl);
	if (response.ok) {
		const xml = await response.text();
		feedItems = parseItems(xml).filter((item) => item.title && item.link);
	}
} catch (error) {
	feedItems = [];
}

const formattedItems: FeedItemWithLabel[] = feedItems.slice(0, maxItems).map((item) => ({
	...item,
	description: item.description ? truncateText(item.description, 200) : '',
	dateLabel:
		item.date && !Number.isNaN(item.date.getTime())
			? item.date.toLocaleDateString('ja-JP', {
				year: 'numeric',
				month: 'short',
				day: 'numeric',
			})
			: '',
}));
---

<section class="note-feed" id="note">
	<div class="container">
		<div class="section-header">
			<h2 class="section-title">Note 最新記事</h2>
			<div class="header-line"></div>
		</div>
		{formattedItems.length ? (
			<>
				<div class="note-grid" data-note-grid>
					{formattedItems.map((item, index) => (
						<article class="note-card" data-note-card data-index={index}>
							<h3>
								<a href={item.link} target="_blank" rel="noopener noreferrer">
									{item.title}
								</a>
							</h3>
							{item.dateLabel ? <p class="note-date">{item.dateLabel}</p> : null}
							{item.description ? <p class="note-description">{item.description}</p> : null}
							<a class="note-link" href={item.link} target="_blank" rel="noopener noreferrer">
								続きを読む <span>→</span>
							</a>
						</article>
					))}
				</div>
				<div class="note-pagination" data-note-pagination>
					<button class="note-arrow" type="button" aria-label="上一頁" data-note-prev>
						←
					</button>
					<button class="note-arrow" type="button" aria-label="下一頁" data-note-next>
						→
					</button>
				</div>
			</>
		) : (
			<p class="note-empty">Note の最新記事を取得できませんでした。</p>
		)}
	</div>
</section>

<script type="module">
	const cards = Array.from(document.querySelectorAll('[data-note-card]'));
	const prevButton = document.querySelector('[data-note-prev]');
	const nextButton = document.querySelector('[data-note-next]');
	const perPage = 8;
	let currentPage = 0;

	const renderPage = () => {
		const totalPages = Math.max(1, Math.ceil(cards.length / perPage));
		const start = currentPage * perPage;
		const end = start + perPage;

		cards.forEach((card, index) => {
			card.style.display = index >= start && index < end ? 'flex' : 'none';
		});

		if (prevButton) {
			prevButton.disabled = currentPage === 0;
		}
		if (nextButton) {
			nextButton.disabled = currentPage >= totalPages - 1;
		}
	};

	if (prevButton && nextButton) {
		prevButton.addEventListener('click', () => {
			currentPage = Math.max(0, currentPage - 1);
			renderPage();
		});
		nextButton.addEventListener('click', () => {
			const totalPages = Math.max(1, Math.ceil(cards.length / perPage));
			currentPage = Math.min(totalPages - 1, currentPage + 1);
			renderPage();
		});
	}

	renderPage();
</script>
