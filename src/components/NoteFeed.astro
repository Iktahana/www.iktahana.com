---
const rssUrl = 'https://note.com/iktahana/rss';
const itemsPerPage = 4;

type FeedItem = {
	title: string;
	link: string;
	description: string;
	date: Date | null;
};

type FeedItemWithLabel = FeedItem & {
	dateLabel: string;
};

const decodeEntities = (value: string) =>
	value
		.replace(/&amp;/g, '&')
		.replace(/&lt;/g, '<')
		.replace(/&gt;/g, '>')
		.replace(/&quot;/g, '"')
		.replace(/&#39;/g, "'");

const cleanText = (value: string) => decodeEntities(value.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim());

const truncateText = (value: string, maxLength: number) =>
	value.length > maxLength ? `${value.slice(0, maxLength).trim()}…` : value;

const extractTag = (item: string, tag: string) => {
	const match = item.match(new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`));
	if (!match) {
		return '';
	}

	return cleanText(match[1].replace(/<!\[CDATA\[|\]\]>/g, ''));
};

const parseItems = (xml: string): FeedItem[] => {
	const items: FeedItem[] = [];
	for (const match of xml.matchAll(/<item>([\s\S]*?)<\/item>/g)) {
		const item = match[1];
		const title = extractTag(item, 'title');
		const link = extractTag(item, 'link');
		const description = extractTag(item, 'description');
		const pubDate = extractTag(item, 'pubDate');
		const date = pubDate ? new Date(pubDate) : null;

		items.push({ title, link, description, date });
	}
	return items;
};

let feedItems: FeedItem[] = [];
try {
	const response = await fetch(rssUrl);
	if (response.ok) {
		const xml = await response.text();
		feedItems = parseItems(xml).filter((item) => item.title && item.link);
	}
} catch (error) {
	feedItems = [];
}

const formattedItems: FeedItemWithLabel[] = feedItems.map((item) => ({
	...item,
	description: item.description ? truncateText(item.description, 200) : '',
	dateLabel:
		item.date && !Number.isNaN(item.date.getTime())
			? item.date.toLocaleDateString('ja-JP', {
				year: 'numeric',
				month: 'short',
				day: 'numeric',
			})
			: '',
}));

const visibleCount = Math.floor(formattedItems.length / itemsPerPage) * itemsPerPage;
const visibleItems = formattedItems.slice(0, visibleCount);

---

<section class="note-feed" id="note">
	<div class="container">
		<div class="section-header">
			<h2 class="section-title">Note 最新記事</h2>
			<div class="header-line"></div>
		</div>
		{visibleItems.length ? (
			<>
				<div class="note-grid" data-note-grid>
					{visibleItems.map((item, index) => (
						<article
							class="note-card"
							data-note-card
							data-index={index}
							hidden={index >= itemsPerPage}
						>

							<h3>
								<a href={item.link} target="_blank" rel="noopener noreferrer">
									{item.title}
								</a>
							</h3>
							{item.dateLabel ? <p class="note-date">{item.dateLabel}</p> : null}
							{item.description ? <p class="note-description">{item.description}</p> : null}
							<a class="note-link" href={item.link} target="_blank" rel="noopener noreferrer">
								続きを読む <span>→</span>
							</a>
						</article>
					))}
				</div>
				<div class="note-pagination" data-note-pagination>
					<button class="note-arrow" type="button" aria-label="上一頁" data-note-prev>
						←
					</button>
					<button class="note-arrow" type="button" aria-label="下一頁" data-note-next>
						→
					</button>
				</div>
			</>
		) : (
			<p class="note-empty">Note の最新記事を取得できませんでした。</p>
		)}
	</div>
</section>

<script type="module">
	const cards = Array.from(document.querySelectorAll('[data-note-card]'));
	const prevButton = document.querySelector('[data-note-prev]');
	const nextButton = document.querySelector('[data-note-next]');
	const grid = document.querySelector('[data-note-grid]');
	const perPage = 4;
	const fadeDuration = 240;
	let currentPage = 0;

	const renderPage = () => {
		const displayCount = Math.floor(cards.length / perPage) * perPage;
		const totalPages = Math.max(1, Math.ceil(displayCount / perPage));
		const start = currentPage * perPage;
		const end = start + perPage;

		cards.forEach((card, index) => {
			const shouldShow = index >= start && index < end && index < displayCount;
			card.toggleAttribute('hidden', !shouldShow);
		});

		if (prevButton) {
			prevButton.disabled = currentPage === 0;
		}
		if (nextButton) {
			nextButton.disabled = currentPage >= totalPages - 1;
		}
	};

	const animateToPage = (nextPage) => {
		if (!grid) {
			currentPage = nextPage;
			renderPage();
			return;
		}

		grid.classList.add('is-fading');
		window.setTimeout(() => {
			currentPage = nextPage;
			renderPage();
			grid.classList.remove('is-fading');
		}, fadeDuration);
	};

	if (prevButton && nextButton) {
		prevButton.addEventListener('click', () => {
			animateToPage(Math.max(0, currentPage - 1));
		});
		nextButton.addEventListener('click', () => {
			const displayCount = Math.floor(cards.length / perPage) * perPage;
			const totalPages = Math.max(1, Math.ceil(displayCount / perPage));
			animateToPage(Math.min(totalPages - 1, currentPage + 1));
		});
	}

	renderPage();
</script>
